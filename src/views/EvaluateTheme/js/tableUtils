/*
 * 根据传入的数据和字段计算所选字段的rowSpan数组
 * 用于格式化带有“合并单元格”的数据
 */
export const genRowSpan = (data, key) => {
    const rowSpan = [];
    let index = 0;
    let lastValue;

    data.forEach(item => {
        if (item[key] === '' || item[key] === '——') {
            index++;
            rowSpan.push(1);
        } else if (item[key] === lastValue) {
            rowSpan[index]++;
            rowSpan.push(0);
        } else {
            lastValue = item[key];
            index += rowSpan[index] ? rowSpan[index] : 0;
            rowSpan.push(1);
        }
    });
    return rowSpan;
}

/*
 * 根据传入的数据和字段生成模型页面的表格数组，4个一组
 */
export const genModelList = (data, dataTemplate) => {
    let modelList = [];
    let tempSubList = [];
    data.forEach(item => {
        if (item.needCalc) {
            tempSubList.push(dataTemplate(item));
            if (tempSubList.length >= 4) {
                modelList.push(tempSubList);
                tempSubList = [];
            }
        }
    });


    return modelList;
}

export const genDataList = (data, key) => {
    let dataList = [];

    let tempList = [];
    data.forEach(item => {
        const temp = item[key];
        if (temp !== '' && tempList.indexOf(temp) === -1) {
            tempList.push(temp);
        }
    })

    let tempSubList = [];
    tempList.forEach(item => {
        tempSubList.push(item);
        if (tempSubList.length >= 4) {
            dataList.push(tempSubList);
            tempSubList = [];
        }
    })
    return dataList;
}

// 解析表达式生成参数列表（供计算表单可视化）和表达式类别（供计算）
export const praseFormula = (formula) => {
    if (formula && formula !== '') {
        const params = [];
        const formulaList = [];

        // 替换各种奇奇怪怪的符号，格式化公式（考虑放到数据文件中）
        formula = formula.replace(/ /g, '').replace(/（/g, '(').replace(/）/g, ')')
            .replace(/／/g, '/').replace(/÷/g, '/').replace(/％/g, '%')
            .replace(/×/g, 'x').replace(/x100%/g, '*100%');
        let temp = '';
        for (let i = 0, len = formula.length; i < len; i++) {
            if (!isOperator(formula[i])) {
                temp += (formula[i] + '');

                // 处理参数是数字的情况(100%也会出现数字，所以对*100%处理放在内部)
                if (temp === parseInt(temp) + '') {
                    const preChar = formula[i - temp.length];
                    const nextChar = formula[i + 1];


                    // 如果数字的下一个字符不是数字，说明数字结束，加入列表
                    if (nextChar !== parseInt(nextChar) + '') {
                        if (temp === '100' && preChar === '*' && nextChar === '%') {
                            // 处理*100%
                            formulaList.push(100);
                            temp = '';
                            i++;
                        } else if (isOperator(preChar) || isOperator(nextChar)) {
                            // 处理其他数字参数，防止中文参数中含有数字，添加前后运算符判断
                            formulaList.push(temp);
                            temp = '';
                        }

                    }

                }
            } else {
                // 当遇到运算符
                if (temp !== '') {
                    params.indexOf(temp) === -1 && params.push(temp);
                    formulaList.push(temp);
                }
                formulaList.push(formula[i]);
                temp = '';
            }

            if (i === len - 1 && temp !== '') {
                if (params.indexOf(temp) === -1) {
                    params.push(temp);
                }
                formulaList.push(temp);
            }
        }

        return {
            paramsList: params,
            formulaList: formulaList
        };
    }
}

const isOperator = (char) => {
    if (char === '+' || char === '-' || char === '*' || char === '/' || char === '%' || char === '(' || char === ')') return true;
    else return false;
}

const isOperator_calc = (char) => {
    if (char === '+' || char === '-' || char === '*' || char === '/' || char === '%' || char === '(' || char === ')' || char === '#') return true;
    else return false;
}

export const calcFormula = (formulaList) => {
    const opStack = ['#'];
    const paramsStack = [];
    formulaList.push('#');

    let i = 0;
    let char = formulaList[i];
    while (char !== '#' || opStack[opStack.length - 1] !== '#') {
        if (!isOperator_calc(char)) {
            paramsStack.push(char);
            char = formulaList[++i];
        } else {
            // 对比栈内和当前运算符优先级
            switch (opPriority(opStack[opStack.length - 1], char)) {
                case 'lt':
                    opStack.push(char);
                    char = formulaList[++i];
                    break;
                case 'eq':
                    // 相等情况为2个()或#相遇，结束当前计算块
                    opStack.pop();
                    char = formulaList[++i];
                    break;
                case 'gt':
                    const param2 = paramsStack.pop();
                    const param1 = paramsStack.pop();
                    const result = operate(param1, opStack.pop(), param2);
                    paramsStack !== undefined && paramsStack.push(result);
                    break;
                case '%%':
                default:
                    // 返回NAN
                    return Number(undefined);
            }
        }//if_else
        // char = formulaList[++i];
    }//while
    return isNaN(paramsStack[paramsStack.length - 1]) ? 0 : paramsStack[paramsStack.length - 1];
}

// 获得运算符优先级
const opPriority = (op1, op2) => {
    // eq代表2个()或#相遇，当前部分计算年结束
    // %%代表计算出错(非法字符下标为7，匹配错误标志)
    const priority = [
        ['gt', 'gt', 'lt', 'lt', 'lt', 'gt', 'gt', '%%'],
        ['gt', 'gt', 'lt', 'lt', 'lt', 'gt', 'gt', '%%'],
        ['gt', 'gt', 'gt', 'gt', 'lt', 'gt', 'gt', '%%'],
        ['gt', 'gt', 'gt', 'gt', 'lt', 'gt', 'gt', '%%'],
        ['lt', 'lt', 'lt', 'lt', 'lt', 'eq', '%%', '%%'],
        ['gt', 'gt', 'gt', 'gt', '%%', 'gt', 'gt', '%%'],
        ['lt', 'lt', 'lt', 'lt', 'lt', '%%', 'eq', '%%'],
        ['%%', '%%', '%%', '%%', '%%', '%%', '%%', '%%']
    ]

    let i, j;

    switch (op1) {
        case '+': i = 0; break;
        case '-': i = 1; break;
        case '*': i = 2; break;
        case '/': i = 3; break;
        case '(': i = 4; break;
        case ')': i = 5; break;
        case '#': i = 6; break;
        default: i = 7;
    }

    switch (op2) {
        case '+': j = 0; break;
        case '-': j = 1; break;
        case '*': j = 2; break;
        case '/': j = 3; break;
        case '(': j = 4; break;
        case ')': j = 5; break;
        case '#': j = 6; break;
        default: j = 7;
    }

    return priority[i][j];
}

const operate = (param1, op, param2) => {
    switch (op) {
        case '+': return param1 + param2;
        case '-': return param1 - param2;
        case '*': return param1 * param2;
        case '/': return param1 / param2;
        default: return undefined;
    }
}
export const handle = (arr) =>{
    return Math.express(arr)
}
Math.express = (function() {

    function express(expression) {
        return cc(c2a(expression));
    }

    // 两个浮点数求和
    express.add = function(a, b) {
        var r1, r2, m;
        try {
            r1 = a.toString().split('.')[1].length;
        } catch (e) {
            r1 = 0;
        }
        try {
            r2 = b.toString().split(".")[1].length;
        } catch (e) {
            r2 = 0;
        }
        m = Math.pow(10, Math.max(r1, r2));
        return Math.round(a * m + b * m) / m;
    }

    // 两个浮点数相减
    express.sub = function(a, b) {
        var r1, r2, m;
        try {
            r1 = a.toString().split('.')[1].length;
        } catch (e) {
            r1 = 0;
        }
        try {
            r2 = b.toString().split(".")[1].length;
        } catch (e) {
            r2 = 0;
        }
        m = Math.pow(10, Math.max(r1, r2));
        let n = (r1 >= r2) ? r1 : r2;
        return (Math.round(a * m - b * m) / m).toFixed(n);
    }

    // 两数相除
    express.div = function(a, b) {
        var t1, t2, r1, r2;
        try {
            t1 = a.toString().split('.')[1].length;
        } catch (e) {
            t1 = 0;
        }
        try {
            t2 = b.toString().split(".")[1].length;
        } catch (e) {
            t2 = 0;
        }
        r1 = Number(a.toString().replace(".", ""));
        r2 = Number(b.toString().replace(".", ""));
        return (r1 / r2) * Math.pow(10, t2 - t1);
    }

    express.mul = function(a, b) {
        var m = 0, s1 = a.toString(), s2 = b.toString();
        try {
            m += s1.split(".")[1].length
        } catch (e) {
        }
        try {
            m += s2.split(".")[1].length
        } catch (e) {
        }
        return Number(s1.replace(".", "")) * Number(s2.replace(".", "")) / Math.pow(10, m);
    }

    // 运算符优先级
    var priority = express.priority = {
        "+" : 1,
        "-" : 1,
        "*" : 9,
        "/" : 9,
        "%" : 9
    };

    var cal = {
        "+" : function(a, b) {
            return express.add(a, b);
        },
        "-" : function(a, b) {
            return express.sub(a, b);
        },
        "*" : function(a, b) {
            return express.mul(a, b);
        },
        "/" : function(a, b) {
            return express.div(a, b);
        }
    };

    // 中缀表达式转后缀表达式
    function c2a(exp) {
        exp = exp.replace(/\s+/g, "").match(/[1-9]\d{0,}(?:\.\d+)?|[\+\-\*\/\%\(\)]/g);
        var stack = [], result = [];
        stack.peek = function() {
            return this[this.length - 1];// 弹出但不删除
        }

        for (var i = 0; i < exp.length; i++) {
            var v = exp[i];
            if (/[1-9]\d{0,}(?:\.\d+)?/.test(v)) {
                // 1.遇到操作数：直接输出（添加到后缀表达式中)
                result.push(v);
            } else if (stack.length === 0) {
                // 2.栈为空时，遇到运算符，直接入栈
                stack.push(v);
            } else if (v == "(") {
                // 3.遇到左括号：将其入栈
                stack.push(v);
            } else if (v == ")") {
                // 4.遇到右括号：执行出栈操作，并将出栈的元素输出，直到弹出栈的是左括号，左括号不输出。
                while (stack.peek() !== "(") {
                    result.push(stack.peek())
                    stack.pop();
                    if (stack.length === 0) {
                        return new Error("error expression"); // 缺少左括号
                    }
                }
                stack.pop();
            } else if (/[\+\-\*\/\%]/.test(v)) {
                // 5.遇到其他运算符：加减乘除：弹出所有优先级大于或者等于该运算符的栈顶元素，然后将该运算符入栈
                while (priority[v] <= priority[stack.peek()]) {
                    result.push(stack.peek())
                    stack.pop();
                }
                stack.push(v);
            }
        }
        // 6.最终将栈中的元素依次出栈，输出。
        while (stack.length > 0) {
            if (stack.peek() === '(') {
                return new Error("error expression"); // 缺少右括号
            }
            result.push(stack.pop())
        }

        return result;
    }

    // 计算结果
    function cc(queue) {
        var v, a, b, stack = [];
        while (queue.length > 0) {
            var v = queue.shift();
            if (/[1-9]\d{0,}(?:\.\d+)?/.test(v)) {
                stack.push(v)
            } else {
                b = stack.pop();
                a = stack.pop();
                stack.push(cal[v](a, b));
            }
        }
        if (stack.length === 1) {
            return stack.pop();
        }

        return null;
    }

    return express;

})();
